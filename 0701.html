<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Базы данных</title>
<style>
  body {
    font-family: Arial, sans-serif;
 line-height: 1.6;
 margin: 20px;
 background-color: #f9f9f9;
}
h1, h2, h3 {
  color: #2c3e50;
}
section {
  background-color: #fff;
  padding: 20px;
  margin-bottom: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

</style>
</head>
<body>

<h1>Базы данных</h1>
<h2>Лекция. Аутентификация соединений с сервером Авторизация логинов для подключения к базам данных </h2>


<section>
  <p>Аутентификация vs. Авторизация: Краткое различие </p>
  <ul>
    <li>Аутентификация (Authentication - AuthN): Процесс проверки подлинности пользователя. Ответ на вопрос "Кто вы?". Это проверка логина/пароля, отпечатка пальца, Face ID и т.д. </li>
    <li>Авторизация (Authorization - AuthZ): Процесс проверки прав пользователя на выполнение определенных действий. Ответ на вопрос "Что вам разрешено делать?". Это проверка ролей (админ, модератор, пользователь) и разрешений (может ли он читать, писать, удалять). </li>
  </ul>
  <p>Простая аналогия: </p>
  <ul>
    <li>Вы предъявляете паспорт на ресепшене отеля -> Аутентификация (доказали, что вы это вы). </li>
    <li>Вам выдают ключ от номера 505, но не от номера 506 -> Авторизация (определили, к чему у вас есть доступ).</li>
  </ul>
</section>
<section>
  <h3>Часть 1: Аутентификация соединений с сервером </h3>
  <p>Здесь речь идет о том, как ваше веб-приложение (клиент) доказывает свою подлинность серверу, на котором работает backend. Это особенно важно для API. </p>
  <p>Распространенные методы аутентификации сервер-сервер или клиент-сервер: </p>
  <ul>
    <li>API Keys (Ключи API)  
            <ol>
        <li>Как работает: Простой длинный уникальный токен, который клиент передает с каждым запросом (обычно в заголовке X-API-Key или как параметр запроса). </li>
        <li>Плюсы: Простота реализации и использование. </li>
        <li>Минусы: Низкая безопасность. Ключ часто передается открыто, его компрометация дает полный доступ. Никогда не используйте для аутентификации пользователей! Подходит для аутентификации сервисов между собой в доверенной среде. </li>
            </ol>
    </li>
    <li>JWT (JSON Web Tokens)  
            <ol>
        <li>Пользователь логинится (отправляет логин/пароль). </li>
        <li>Сервер проверяет данные, создает JWT-токен (подписанный цифровой подписью) и отдает его клиенту. </li>
        <li>Клиент сохраняет токен (часто в LocalStorage или Cookies) и передает его в заголовке Authorization: Bearer <токен> при каждом последующем запросе. </li>
        <li>Сервер проверяет подпись токена и извлекает из него данные (например, user id). Ему не нужно хранить сессию на сервере (stateless). </li>
            </ol>
    </li>
    <li>OAuth 2.0 / OpenID Connect 
            <ol>
        <li>Как работает: Делегированная аутентификация. Пользователь аутентифицируется на доверенном сервисе (например, Google, GitHub, Facebook), который затем выдает вашему приложению токен доступа. </li>
        <li>Плюсы: Пользователям не нужно создавать новый пароль. Высокий уровень безопасности, так как пароли обрабатываются крупными провайдерами. </li>
        <li>Минусы: Более сложная реализация на стороне backend. </li>
    </ol>
    </li>
    <li>Аутентификация на основе сессий (Cookies)  
            <ol>
        <li>Пользователь логинится.</li>
        <li>Сервер создает запись сессии в базе данных или in-memory хранилище (например, Redis) и отправляет клиенту идентификатор сессии (Session ID) в cookie (с флагами HttpOnly, Secure). </li>
        <li>Браузер автоматически отправляет этот cookie с каждым запросом.</li>
        <li>Сервер проверяет ID сессии в своем хранилище. </li>
            </ol>
    </li>
  </ul>
</section>

<section>
  <p>Часть 2: Авторизация логинов для подключения к базам данных </p>
  <p>Здесь речь идет о том, как ваше backend-приложение подключается к СУБД (MySQL, PostgreSQL, MongoDB и т.д.). Это служебная, а не пользовательская авторизация. <br>Ключевые принципы: </p>
    <ul>
    <li>Принцип наименьших привилегий (Principle of Least Privilege)   
            <ol>
        <li>Это золотое правило. Учетная запись, которую использует ваше приложение для подключения к БД, должна иметь ровно те права, которые ей необходимы, и не более. </li>
        <li>Пример: Если ваше приложение только читает данные из таблицы articles, его пользователь БД должен иметь право только SELECT на эту таблицу, но не INSERT, UPDATE, DELETE или DROP. </li>
            </ol>
    </li>
    <li>Использование разных учетных записей для разных целей  
            <ol>
        <li>Не используйте одну супер-учетку (root/admin) для всего.</li>
        <li>Создайте отдельного пользователя БД специально для вашего приложения. </li>
        <li>Для разных сервисов (основное приложение, скрипты миграции, analytics) можно создать разных пользователей с разными правами. </li>
            </ol>
    </li>
    <li>Безопасное хранение учетных данных  
            <ol>
        <li>Никогда не храните логины/пароли от БД в коде приложения (в гите)! </li>
        <li>Используйте переменные окружения (Environment Variables) или секреты (Secrets)</li>
    </ol>
    </li>
    <li>Использование SSL/TLS для подключения к БД  
            <ol>
        <li>Особенно критично, если ваша БД находится на удаленном сервере (не на том же хосте, что и приложение).</li>
        <li>Это шифрует весь трафик между приложением и СУБД, защищая данные от перехвата. </li>
            </ol>
    </li>
  </ul>
  <p>Итог: Всегда разделяйте аутентификацию пользователей вашего приложения и аутентификацию самого приложения для доступа к БД. Для обоих случаев применяйте принцип наименьших привилегий и никогда не храните секреты в коде. </p>
</section>

<h1>Лекция. Требования безопасности к серверам баз данных. Классы защиты</h1>

<section>
  <p1>Введение: Почему безопасность БД — это важно?</p1>
  <ol>
    <li>Ценность данных: БД хранят ПДн, финансовую отчетность, коммерческую тайну, интеллектуальную собственность.</li>
    <li>Последствия взлома:
      <ul>
        <li>Прямые убытки: Кража денег, штрафы по GDPR, КоАП, PCI DSS.</li>
        <li>Репутационные потери: Утрата доверия клиентов и партнеров.</li>
        <li>Операционные потери: Остановка бизнес-процессов, шантаж (ransomware).</li>
      </ul>
    </li>
  </ol>
</section>

<section>
  <p1>Часть 1: Многоуровневая модель безопасности (Defense in Depth)</p1>
  <p>1. Уровень сети (Network Security)</p>
  <ul>
    <li>Принцип: «Спрятать» СУБД от всего мира.</li>
    <li>Меры:
      <ul>
        <li>Изоляция: Размещение БД в отдельном, изолированном сегменте сети (DMZ, VLAN).Никаких прямых подключений из интернета.</li>
        <li>Firewall (Брандмауэр):
          <ul>
            <li>Хостый: iptables (Linux), Windows Firewall.</li>
            <li>Сетевой: Правила, разрешающие входящие подключения только с конкретных IP-адресов application-серверов (принцип наименьших привилегий на сетевом уровне).</li>
            <li>Запрет всех неиспользуемых портов.</li>
          </ul>
        </li>
        <li>Шифрование трафика: Использование SSL/TLS для соединений между приложением и БД. Защита от сниффинга (перехвата тракта).</li>
      </ul>
    </li>
  </ul>
<p>2. Уровень доступа к серверу (Host Security)</p>
  <ul>
    <li>Принцип: Укрепить ОС, на которой работает СУБД.</li>
    <li>Меры:
      <ul>
        <li>Минимизация поверхности атаки: Удаление всех ненужных пакетов, служб, отключение неиспользуемых портов.</li>
        <li>Своевременное обновление: Регулярный патчинг ОС и СУБД для устранения известных уязвимостей.</li>
        <li>Дисковая шифровка: Full-disk encryption (e.g., LUKS, BitLocker) для защиты данных на физическом носителе.</li>
        <li>Отдельный пользователь ОС: Запуск СУБД от имени непривилегированного пользователя (не root!).</li>
      </ul>
    </li>
  </ul>
  <p>3. Уровень доступа к СУБД (Database Access Control)</p>
  <ul>
    <li>Принцип: Аутентификация и авторизация.</li>
    <li>Меры:
      <ul>
        <li>Сильные пароли:</li>
        <li>Принцип наименьших привилегий (Least Privilege): Пользователь/приложение получает ровно те права, которые нужны для работы, и не более.
          <ul>
            <li>Пользователю для веб-приложения не нужны права CREATE TABLE, DROP, GRANT OPTION.</li>
          </ul>
        </li>
        <li>Отказ от учетных записей по умолчанию:</li>
        <li>Разделение обязанностей (SoD): Администратор БД, администратор безопасности, оператор резервного копирования — должны быть разные люди/учетные записи.</li>
      </ul>
    </li>
  </ul>
  <p>4. Уровень данных (Data Security)</p>
  <ul>
    <li>Принцип: Защита данных даже при компрометации вышележащих уровней.</li>
    <li>Меры:
      <ul>
        <li>Шифрование данных:</li>
        <li>Для тестовых и сред разработки. Реальные данные заменяются на правдоподобные фиктивные.</li>
        <li>Хэширование: : Для хранения паролей обязательно использовать современные алгоритмы хэширования с солью (bcrypt, scrypt, Argon2). Никогда не хранить пароли в открытом виде!</li>
      </ul>
    </li>
  </ul>
  <p>5. Уровень аудита и мониторинга (Auditing & Monitoring)</p>
  <ul>
    <li>Принцип: Обнаружение и расследование инцидентов.</li>
    <li>Меры:
      <ul>
        <li>Включение ведения логов: Логирование всех попыток входа (успешных и неуспешных), попыток доступа к бд, изменений схемы БД.</li>
        <li>Centralized Logging: Отправка логов на выделенный сервер (лог-сервер) для защиты от модификации злоумышленником.</li>
        <li>SIEM-системы: Использование систем для анализа логов и выявления аномалий (например, 1000 попыток входа за минуту с одного IP).</li>
        <li>Регулярный аудит: Проверка настроек безопасности, прав пользователей.</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <p1>Итог:</p1>
  <p>Безопасность БД — это непрерывный процесс, а не разовое действие. Она требует комплексного подхода, покрывает все уровни: от физического до уровня приложений, и должна быть основана на принципах «запрещено всё, что не разрешено явно» и «минимум привилегий».</p>
</section>